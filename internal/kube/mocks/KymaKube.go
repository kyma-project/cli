// Code generated by mockery v2.38.0. DO NOT EDIT.

package mocks

import (
	api "k8s.io/client-go/tools/clientcmd/api"
	client "sigs.k8s.io/controller-runtime/pkg/client"

	context "context"

	corev1 "k8s.io/api/core/v1"

	dynamic "k8s.io/client-go/dynamic"

	kubernetes "k8s.io/client-go/kubernetes"

	mock "github.com/stretchr/testify/mock"

	rest "k8s.io/client-go/rest"

	schema "k8s.io/apimachinery/pkg/runtime/schema"

	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	v1 "k8s.io/api/apps/v1"

	versioned "istio.io/client-go/pkg/clientset/versioned"
)

// KymaKube is an autogenerated mock type for the KymaKube type
type KymaKube struct {
	mock.Mock
}

// Apply provides a mock function with given fields: ctx, force, objs
func (_m *KymaKube) Apply(ctx context.Context, force bool, objs ...client.Object) error {
	_va := make([]interface{}, len(objs))
	for _i := range objs {
		_va[_i] = objs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, force)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Apply")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, bool, ...client.Object) error); ok {
		r0 = rf(ctx, force, objs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Ctrl provides a mock function with given fields:
func (_m *KymaKube) Ctrl() client.WithWatch {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ctrl")
	}

	var r0 client.WithWatch
	if rf, ok := ret.Get(0).(func() client.WithWatch); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.WithWatch)
		}
	}

	return r0
}

// DefaultNamespace provides a mock function with given fields:
func (_m *KymaKube) DefaultNamespace() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DefaultNamespace")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Dynamic provides a mock function with given fields:
func (_m *KymaKube) Dynamic() dynamic.Interface {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Dynamic")
	}

	var r0 dynamic.Interface
	if rf, ok := ret.Get(0).(func() dynamic.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dynamic.Interface)
		}
	}

	return r0
}

// IsPodDeployed provides a mock function with given fields: namespace, name
func (_m *KymaKube) IsPodDeployed(namespace string, name string) (bool, error) {
	ret := _m.Called(namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for IsPodDeployed")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(namespace, name)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(namespace, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsPodDeployedByLabel provides a mock function with given fields: namespace, labelName, labelValue
func (_m *KymaKube) IsPodDeployedByLabel(namespace string, labelName string, labelValue string) (bool, error) {
	ret := _m.Called(namespace, labelName, labelValue)

	if len(ret) == 0 {
		panic("no return value specified for IsPodDeployedByLabel")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string) (bool, error)); ok {
		return rf(namespace, labelName, labelValue)
	}
	if rf, ok := ret.Get(0).(func(string, string, string) bool); ok {
		r0 = rf(namespace, labelName, labelValue)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(namespace, labelName, labelValue)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Istio provides a mock function with given fields:
func (_m *KymaKube) Istio() versioned.Interface {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Istio")
	}

	var r0 versioned.Interface
	if rf, ok := ret.Get(0).(func() versioned.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(versioned.Interface)
		}
	}

	return r0
}

// KubeConfig provides a mock function with given fields:
func (_m *KymaKube) KubeConfig() *api.Config {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for KubeConfig")
	}

	var r0 *api.Config
	if rf, ok := ret.Get(0).(func() *api.Config); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Config)
		}
	}

	return r0
}

// ParseManifest provides a mock function with given fields: manifest
func (_m *KymaKube) ParseManifest(manifest []byte) ([]client.Object, error) {
	ret := _m.Called(manifest)

	if len(ret) == 0 {
		panic("no return value specified for ParseManifest")
	}

	var r0 []client.Object
	var r1 error
	if rf, ok := ret.Get(0).(func([]byte) ([]client.Object, error)); ok {
		return rf(manifest)
	}
	if rf, ok := ret.Get(0).(func([]byte) []client.Object); ok {
		r0 = rf(manifest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.Object)
		}
	}

	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(manifest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestConfig provides a mock function with given fields:
func (_m *KymaKube) RestConfig() *rest.Config {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for RestConfig")
	}

	var r0 *rest.Config
	if rf, ok := ret.Get(0).(func() *rest.Config); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rest.Config)
		}
	}

	return r0
}

// Static provides a mock function with given fields:
func (_m *KymaKube) Static() kubernetes.Interface {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Static")
	}

	var r0 kubernetes.Interface
	if rf, ok := ret.Get(0).(func() kubernetes.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kubernetes.Interface)
		}
	}

	return r0
}

// WaitDeploymentStatus provides a mock function with given fields: namespace, name, cond, status
func (_m *KymaKube) WaitDeploymentStatus(namespace string, name string, cond v1.DeploymentConditionType, status corev1.ConditionStatus) error {
	ret := _m.Called(namespace, name, cond, status)

	if len(ret) == 0 {
		panic("no return value specified for WaitDeploymentStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, v1.DeploymentConditionType, corev1.ConditionStatus) error); ok {
		r0 = rf(namespace, name, cond, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitPodStatus provides a mock function with given fields: namespace, name, status
func (_m *KymaKube) WaitPodStatus(namespace string, name string, status corev1.PodPhase) error {
	ret := _m.Called(namespace, name, status)

	if len(ret) == 0 {
		panic("no return value specified for WaitPodStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, corev1.PodPhase) error); ok {
		r0 = rf(namespace, name, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitPodStatusByLabel provides a mock function with given fields: namespace, labelName, labelValue, status
func (_m *KymaKube) WaitPodStatusByLabel(namespace string, labelName string, labelValue string, status corev1.PodPhase) error {
	ret := _m.Called(namespace, labelName, labelValue, status)

	if len(ret) == 0 {
		panic("no return value specified for WaitPodStatusByLabel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, corev1.PodPhase) error); ok {
		r0 = rf(namespace, labelName, labelValue, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WatchObject provides a mock function with given fields: ctx, obj, checkFn
func (_m *KymaKube) WatchObject(ctx context.Context, obj client.Object, checkFn func(client.Object) (bool, error)) error {
	ret := _m.Called(ctx, obj, checkFn)

	if len(ret) == 0 {
		panic("no return value specified for WatchObject")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, func(client.Object) (bool, error)) error); ok {
		r0 = rf(ctx, obj, checkFn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WatchResource provides a mock function with given fields: res, name, namespace, checkFn
func (_m *KymaKube) WatchResource(res schema.GroupVersionResource, name string, namespace string, checkFn func(*unstructured.Unstructured) (bool, error)) error {
	ret := _m.Called(res, name, namespace, checkFn)

	if len(ret) == 0 {
		panic("no return value specified for WatchResource")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(schema.GroupVersionResource, string, string, func(*unstructured.Unstructured) (bool, error)) error); ok {
		r0 = rf(res, name, namespace, checkFn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewKymaKube creates a new instance of KymaKube. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKymaKube(t interface {
	mock.TestingT
	Cleanup(func())
}) *KymaKube {
	mock := &KymaKube{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
